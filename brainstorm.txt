-- Command to list info about device
- PID/VID can get from go library
- Output can be in multiple formats? Maybe see how go handles serialization? Maybe only
  json for now
- The device "board type" can be retrieved using the python list (make it a dictionary?)
- Whether the bootloader is active can be pulled from the vid/pid as well. consider how to
  do this in the dictionary? Maybe a simple array of structs?
- The actual device name (Arduboy Mini/etc) can't be pulled with this stupid go library. 
  You'll need to check the bootloader
- Can return jdec info as well, for the size (maybe) and the manufacturer and stuff

- Do we return a list? Sure, each entry can list the endpoint you can find the device on

Now that we have the thing outputting a list:
- Need the cli argument parser thing.


Let's at least get sketch reading done:
- Simple CLI can be made into something more complex with scripting, don't let the
  system get too complicated
- Sketch read is simple: just read the data and output to a file. The CLI should
  perhaps output data relevant to the sketch. 
  - Sketch read should always just read the sketch, but there may be a DIFFERENT
    command to read more, and output a hex
  - consider that some output may be suitable for writing to a pipe (such as the 
    sketch as a .hex) but others won't be (.arduboy as zip)
  - default filename is generated but can be overridden. because of this, what 
    do we return from the call? more json, probably, to make it consistent.
  - want the filename at the very least. Some information maybe? At least get the 
    filename and other things can come later (md5? are we working that into the filename?)
  - md5 in filename means that if you dump multiple times, it will be fine. 
    - seconds in filename isn't enough, but don't want to make the filename too long.
      md5 is 32 chars , that's already too long. 
    - What do people want? perhaps a filename should just be required... no, that sucks
    - 692c8a0cc5e7feb278d7702262577ba4_20240310-2110.hex
      is that ridiculous? mmmm... maybe? hash will at least let you know which program it isn


- Don't want to do the sketch write until the flashcart scanning is implemented, so 
  we can be safe when writing the dev data (don't want to overwrite the end of the flashcart)
  - Sometimes the JEDEC doesn't include the flashcart size (apparently), so the user will need 
    to supply that 
- Parse and generate flashcart header
- Scan flashcart (on device), parse, and let users... do what? One thing is to read the whole
  flashcart, which shouldn't be too much of a problem. Another is to just get headers to find
  a certain program, or to parse all headers. Some will want to read the image too. If we pass
  a function, how will it be able to read the various parts it needs to?
  - Interface for reading arbitrary sections from flash? Possible, I guess. 
  - Just have a couple different functions and make the user figure out what to do in memory?
    Could be fine; headers are only 256 bytes, probably at most 256k. But with images...
    flash memory is at most 16mb now, but in the future it will be 500mb or something. 
    Can't store the whole thing, will need to stream. 
  - Streaming interface... how? Generator. Functions to read parts?

- Absolute need to solve the flashcart reading problem:
  - Can scan through flashcart, reading only one page at a time, and returning the headers.
    Using the headers, you can read further data as long as there's functions to read blocks
    from the flashcart. 
    - There shouldn't be any waste other than repeating commands more than needed, since 
      everything is aligned to a page and I think flashcart read commands are all page based
  - ReadFlash(page, amount)
  - ReadhFlashcart(page, amount)
    - Usually don't need to read arbitrary data from flash, so only the flashcart is really 
      necessary. Can maybe have wrapper functions to read images and the game itself or 
      flashcart data/save but mmm... only if necessary


