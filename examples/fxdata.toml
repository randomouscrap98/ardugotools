# An example file to generate fx data. Although more verbose than
# the python fxdata.txt format, it supports more robust strings and
# can be extended in the future to support far more features.

# NOTE: if you need FX save data, simply set this to 1. Setting to
# other values is TECHNICALLY supported, but the current FX library 
# on Arduboy makes other values than 1 basically pointless.
MinSaveLength = 1 # Reserve space in the fx data for save

# ABOUT SAVE: you generally do not directly read and write bytes into 
# the FX save; instead you call FX::saveGameState and FX::loadGameState, 
# which does some automatic wear leveling and zeroing out to make the 
# flash work. You cannot flash arbitrary data to the FX, it must be 
# "cleared" first, then written. The FX library reduces wear by only 
# zeroing out when necessary. The library is rather limited however, in 
# that it only considers specifically a 4096 byte chunk. I have 
# 'MinSaveLength' set up such that, if the library changes in the future 
# to be more robust, or if someone writes a more robust library, you 
# can reserve more space.

# Store an image into the fx data named 'myspritesheet'. You can 
# optionally split the image into tiles by setting a width and height, 
# as seen here. If not set, the image is stored as a single giant image.
[Data.myspritesheet]
Data = "spritesheet.png"
Format = "image"
Image = {
  # Width and height of each individual sprite. Default = size of image
  Width = 16,
  Height = 16,
  # The space between each sprite, including on the edges. For instance, 
  # this says there is 8 pixels of unused space on the edges of the sprite
  # sheet and 8 pixels of unused space between each sprite. Default = 0
  Spacing = 8,
  # Whether to use alpha as a mask, which is then woven into the data.
  # Default = false
  UseMask = true,
  # The upper bound for what is considered 'black'. The average of the three
  # channels are taken per pixel, so here we are considering anything that is
  # "slightly less than half bright" to be black on the arduboy. Default = 100
  Threshold = 100,
  # The upper bound for what is considered 'transparent' (alpha channel value).
  # Here, we are saying a transparent pixel is anything that is 
  # "almost entirely" transparent (10/255). Default = 10
  AlphaThreshold = 10
}

# Some raw data. Hex data is ALWAYS written as bytes, not as the hex
# string itself. It is useful for encoding raw data generated from another
# program, like a map or such.
[Data.myhexdata]
Data = "000102030405060708090A0B0C0D0E0F10"
Format = "hex"

# Some raw data. Same as hex, where the bytes are stored and not the string.
# Just another way for you to store data, if for some reason you don't like hex
[Data.mybase64]
Data = "SGVsbG8gd29ybGQh"
Format = "base64"

# Data taken directly from a raw file. The file is copied byte-by-byte with
# absolutely no modifications performed.
[Data.myfile]
Data = "uneven.bin"
Format = "file"

# And finally a string. If you want to store multiple strings as an array, 
# currently you should probably stitch them all together with \0 between each,
# then generate some other data that tells how long each string is. If there's
# a demand, I can add some automated way to do this in the future (I just don't
# currently know how people want it to work). Unlike hex and base64, the string
# IS stored as-is, just with the null terminator added at the end
[Data.mystring]
Data = "owo uwu !@#$%^&*()-_[]{}|;:?/.><,+=`~Z188"
Format = "string"

